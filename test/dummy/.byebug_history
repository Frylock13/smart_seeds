exit
object.as_json
object
worker
exit
worker
worker.status
worker
worker.add object.as_json
object.save
object
worker.add object.as_json
Test.last
worker.add object.as_json
object
exit
object
exit
object['status']
object[column.name] = generate_value(column)
object['status']
object[column.name] = generate_value(column)
object['status']
object[column.name] = generate_value(column)
object['status']
object[column.name] = generate_value(column)
object['status']
object[column.name] = generate_value(column)
is_column_must_be_skipped?(column.name)
column.name
next
column.name
next
column.name
next
column.name
next
column.name
next
column.name
next
column.name
next
column.name
next
column.name
exit
enum.enum?
enum.generate_value
enum.enum?
enum.generate_value
enum.enum?
exit
enum.generate_value
enum.enum?
enum
enum = SmartSeeds::Generator::Enum.new(column, model)
enum
exit
column.name
enum?
exit
Entity.last
worker.save!
worker.save
worker
worker.add object.as_json
object.status
object
exit
attrs.each do |attr|
attr.each do |attr|
        key = attr.first
attrs.each do |attr|
attrs
attrs.each do |attr|
object
      end
        object[key.to_s] = value
        value = attr.last
        key = attr.first
attrs.each do |attr|
attrs
model.column_defaults
skippable_attributes
exit
object
object.as_json
object.as_json.class
object.as_json
object.to_hash
object.map(&:attributes)
object
hash
object.instance_variables.each {|var| hash[var.to_s.delete("@")] = object.instance_variable_get(var) }
object.instance_variables.each {|var| hash[var.to_s.delete("@")] = gift.instance_variable_get(var) }
hash = {}
Hash.new(object)
object
object.methods
object
exit
model.name.downcase
model.name.lowercase
model.name
exit
EXIT
include ActiveSupport::Inflector
require ActiveSupport::Inflector
camelize(column_name_without_id)
column_name_without_id
column.name
exit
determine_klass
model_associations.map(&:name).include?(column_name_without_id.to_sym)
column_name_without_id.to_sym
column_name_without_id
associations_include_column?
model_associations
model
exit
model.reflect_on_all_associations(:belongs_to)
model
model_associations
model
foreign_key?
column
exit
foreign_key?
enum?
exit
klass.new(column, model).generate_value
klass = "SmartSeeds::Generator::#{column.type.to_s.capitalize}".constantize
column
exit
klass.new(column, model).generate_value
klass = "SmartSeeds::Generator::#{column.type.to_s.capitalize}".constantize
        i
column
exit
column.name
column
column_name_without_id
 assocation.first.name
 assocation.first
 assocation.first.options[:class_name]
assocation = model_associations.select { |obj| obj.name == column_name_without_id }
column_name_without_id
associations_include_column?
column
exit
exi
klass.new(column, model).generate_value
klass
"SmartSeeds::Generator::#{column.type.to_s.capitalize}".constantize
column
exit
klass.new(column, model).generate_value
klass = "SmartSeeds::Generator::#{column.type.to_s.capitalize}".constantize
klass.new(column, model).generate_value
"SmartSeeds::Generator::#{column.type.to_s.capitalize}".constantize
column
exit
a.first.options[:class_name].constantize
a.first.options[:class_name]
a.first.options
a.options
a = model_associations.select {|obj| obj.name == column_name_without_id}
model_associations.select {|obj| obj.name == column_name_without_id}
column_name_without_id
model_associations
exit
model_associations.first
model_associations
associations_include_column?
exit
column.name.sub /^*_id/, ''
column.name.sub /^*_id/
column.name.sub /*_id/
column.name
c
c.slice!('_id')
c.slice('_id')
c = column.name
associations_include_column?
c
c.slice! '_id'
c = column.name
column.name
column.name.slice '_id'
column.slice '_id'
column.slice _id
column.name.tr('_id', '')
column.name.tr('id', '')
column.name.tr('_id', '')
column.name
column_name
column.name.tr('_id', '')
column.name.tr('_id')
model_associations.map(&:name).include?(column_name_without_id)
model_associations.map(&:name)
column_name_without_id = splitted_column_name.take(splitted_column_name.count - 1).join('_').to_sym
model_associations.map(&:name)
model_associations.map(&:name).include?(column_name_without_id)
column_name_without_id = splitted_column_name.take(splitted_column_name.count - 1).join('_')
column_name_without_id = splitted_column_name.take(splitted_column_name.count - 1).map(&:capitalize).join
column_name_without_id = splitted_column_name.take(splitted_column_name.count - 1)
splitted_column_name = column.name.split('_')
associations_include_column?
column.name
exit
column.name
associations_include_column?
model_associations
model
column
exit
foreign_key?
enum?
exit
column
model
is_foreign_key?
exit
skippable_column_names
skippable_column_names.concat keys_with_default_values
keys_with_default_values = model.column_defaults.select{|key, value| value.present? }.keys
skippable_column_names.class
skippable_column_names
exit
skippable_column_names
skippable_column_names.class
skippable_column_names += keys_with_default_values
skippable_column_names
keys_with_default_values = model.column_defaults.select{|key, value| value.present? }.keys
add_skippable_attributes
exit
add_skippable_attributes
skippable_column_names
skippable_column
exit
super
column
exit
generate_faker_value 
is_comatible_with_faker?
exit
klass = convert_column_name.constantize
klass = convert_column_name
exit
klass = convert_column_name
convert_column_name
conver_column_name
exit
column.name.split('_')
convert_column_name
